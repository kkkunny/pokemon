// Code generated by AI; DO NOT EDIT.
package imgutil

import (
	"image/color"
	"image/draw"
	"math"
)

// 定义圆角矩形的参数
type roundedRect struct {
	X, Y          int         // 左上角坐标
	Width, Height int         // 宽高
	Radius        int         // 圆角半径
	FillColor     color.Color // 填充颜色
	BorderColor   color.Color // 边框颜色
	BorderWidth   int         // 边框宽度
}

// 在图像上绘制圆角矩形
func drawRoundedRect(img draw.Image, rect roundedRect) {
	// 先绘制填充
	if rect.FillColor != nil {
		drawFilledRoundedRect(img, rect)
	}

	// // 如果有边框，绘制边框
	// if rect.BorderWidth > 0 && rect.BorderColor != nil {
	// 	// 创建一个边框矩形（内部缩小）
	// 	borderRect := roundedRect{
	// 		X:           rect.X,
	// 		Y:           rect.Y,
	// 		Width:       rect.Width,
	// 		Height:      rect.Height,
	// 		Radius:      rect.Radius,
	// 		FillColor:   nil,
	// 		BorderColor: rect.BorderColor,
	// 		BorderWidth: rect.BorderWidth,
	// 	}
	// 	drawRoundedRectBorder(img, borderRect)
	// }
}

// 绘制填充的圆角矩形
func drawFilledRoundedRect(img draw.Image, rect roundedRect) {
	// 获取图像尺寸
	bounds := img.Bounds()
	imgWidth, imgHeight := bounds.Dx(), bounds.Dy()

	// 确保坐标在图像范围内
	x1 := max(0, rect.X)
	y1 := max(0, rect.Y)
	x2 := min(imgWidth-1, rect.X+rect.Width)
	y2 := min(imgHeight-1, rect.Y+rect.Height)
	r := rect.Radius

	// 确保圆角半径不超过矩形的一半
	r = min(r, (x2-x1)/2)
	r = min(r, (y2-y1)/2)

	// 填充中间矩形部分（不包括圆角）
	for y := y1 + r; y <= y2-r; y++ {
		for x := x1; x <= x2; x++ {
			img.Set(x, y, rect.FillColor)
		}
	}

	// 填充左右两侧矩形（不包括圆角）
	for y := y1; y <= y2; y++ {
		for x := x1 + r; x <= x2-r; x++ {
			img.Set(x, y, rect.FillColor)
		}
	}

	// 填充四个圆角
	// drawCorner(img, x2-r, y1+r, r, 0, rect.FillColor) // 右上
	// drawCorner(img, x1+r, y1+r, r, 1, rect.FillColor) // 左上
	// drawCorner(img, x1+r, y2-r, r, 2, rect.FillColor) // 左下
	// drawCorner(img, x2-r, y2-r, r, 3, rect.FillColor) // 右下
}

// 绘制圆角矩形的边框
func drawRoundedRectBorder(img draw.Image, rect roundedRect) {
	// 获取图像尺寸
	bounds := img.Bounds()
	imgWidth, imgHeight := bounds.Dx(), bounds.Dy()

	// 确保坐标在图像范围内
	x1 := max(0, rect.X)
	y1 := max(0, rect.Y)
	x2 := min(imgWidth-1, rect.X+rect.Width)
	y2 := min(imgHeight-1, rect.Y+rect.Height)
	r := rect.Radius
	w := rect.BorderWidth

	// 确保圆角半径不超过矩形的一半
	r = min(r, (x2-x1)/2)
	r = min(r, (y2-y1)/2)

	// 绘制上下两条边
	for i := 0; i < w; i++ {
		for x := x1 + r; x <= x2-r; x++ {
			if y1+i < imgHeight {
				img.Set(x, y1+i, rect.BorderColor) // 上边
			}
			if y2-i >= 0 && y2-i < imgHeight {
				img.Set(x, y2-i, rect.BorderColor) // 下边
			}
		}
	}

	// 绘制左右两条边
	for i := 0; i < w; i++ {
		for y := y1 + r; y <= y2-r; y++ {
			if x1+i < imgWidth {
				img.Set(x1+i, y, rect.BorderColor) // 左边
			}
			if x2-i >= 0 && x2-i < imgWidth {
				img.Set(x2-i, y, rect.BorderColor) // 右边
			}
		}
	}

	// 绘制四个圆角的边框
	for i := 0; i < w; i++ {
		drawCornerBorder(img, x2-r, y1+r, r-i, 0, rect.BorderColor) // 右上
		drawCornerBorder(img, x1+r, y1+r, r-i, 1, rect.BorderColor) // 左上
		drawCornerBorder(img, x1+r, y2-r, r-i, 2, rect.BorderColor) // 左下
		drawCornerBorder(img, x2-r, y2-r, r-i, 3, rect.BorderColor) // 右下
	}
}

// 绘制填充的圆角
// corner: 0=右上, 1=左上, 2=左下, 3=右下
func drawCorner(img draw.Image, xc, yc, r int, corner int, col color.Color) {
	bounds := img.Bounds()
	imgWidth, imgHeight := bounds.Dx(), bounds.Dy()

	startAngle, endAngle := 0.0, 0.0
	switch corner {
	case 0: // 右上
		startAngle, endAngle = 0, math.Pi/2
	case 1: // 左上
		startAngle, endAngle = math.Pi/2, math.Pi
	case 2: // 左下
		startAngle, endAngle = math.Pi, 3*math.Pi/2
	case 3: // 右下
		startAngle, endAngle = 3*math.Pi/2, 2*math.Pi
	}

	// 填充圆角区域
	for y := yc - r; y <= yc+r; y++ {
		for x := xc - r; x <= xc+r; x++ {
			// 计算点到圆心的距离
			dx, dy := float64(x-xc), float64(y-yc)
			dist := math.Sqrt(dx*dx + dy*dy)

			// 计算角度
			angle := math.Atan2(dy, dx)
			if angle < 0 {
				angle += 2 * math.Pi
			}

			// 检查点是否在圆角区域内
			if dist <= float64(r) && angle >= startAngle && angle <= endAngle {
				if x >= 0 && x < imgWidth && y >= 0 && y < imgHeight {
					img.Set(x, y, col)
				}
			}
		}
	}
}

// 绘制圆角边框
func drawCornerBorder(img draw.Image, xc, yc, r int, corner int, col color.Color) {
	bounds := img.Bounds()
	imgWidth, imgHeight := bounds.Dx(), bounds.Dy()

	startAngle, endAngle := 0.0, 0.0
	switch corner {
	case 0: // 右上
		startAngle, endAngle = 0, math.Pi/2
	case 1: // 左上
		startAngle, endAngle = math.Pi/2, math.Pi
	case 2: // 左下
		startAngle, endAngle = math.Pi, 3*math.Pi/2
	case 3: // 右下
		startAngle, endAngle = 3*math.Pi/2, 2*math.Pi
	}

	// 绘制圆弧
	for angle := startAngle; angle <= endAngle; angle += 0.01 {
		x := int(float64(xc) + float64(r)*math.Cos(angle))
		y := int(float64(yc) + float64(r)*math.Sin(angle))

		if x >= 0 && x < imgWidth && y >= 0 && y < imgHeight {
			img.Set(x, y, col)
		}
	}
}
